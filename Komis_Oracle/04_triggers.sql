-- ############################################################
-- triggers.sql — definicje triggerów Oracle
-- Projekt: "komis"
-- ############################################################

----------------------------------------------------------------
-- 0) TABELA AUDYTU
-- (Nowe — wymagane przez zadanie: audyt kto/kiedy/co)
----------------------------------------------------------------
CREATE TABLE audit_log
(
  id_audit     NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  tabela       VARCHAR2(30) NOT NULL,
  operacja     VARCHAR2(10) NOT NULL,
  pk_value     VARCHAR2(200),
  kolumna      VARCHAR2(30),
  old_value    VARCHAR2(4000),
  new_value    VARCHAR2(4000),
  who_user     VARCHAR2(128) NOT NULL,
  who_osuser   VARCHAR2(128),
  who_host     VARCHAR2(128),
  client_id    VARCHAR2(128),
  change_ts    TIMESTAMP NOT NULL
);

----------------------------------------------------------------
-- 0.1) KOLUMNA AGREGATU (spójność pośrednia)
-- Wymóg zadania: trigger utrzymujący agregat
----------------------------------------------------------------
ALTER TABLE plac ADD (liczba_aut NUMBER DEFAULT 0 NOT NULL);

----------------------------------------------------------------
-- 1) TRIGGER: Historia zmian ceny samochodu
-- Mapowanie:
--  - Twój PostgreSQL #1: log_cena_update
--  - Wymóg zadania: trigger audytowo-logujący zmianę danych
----------------------------------------------------------------
CREATE OR REPLACE TRIGGER trg_historia_cen
AFTER UPDATE OF cena ON samochod
FOR EACH ROW
WHEN (OLD.cena != NEW.cena)
BEGIN
  INSERT INTO historia_cen (id_samochod, stara_cena, nowa_cena)
  VALUES (:OLD.id_samochod, :OLD.cena, :NEW.cena);
END;
/

----------------------------------------------------------------
-- 2) TRIGGER WALIDACYJNY transakcji
-- Mapowanie:
--  - Twój PostgreSQL #2: check_car_ready_for_sale
--  - Wymóg zadania #1: trigger walidacyjny (BEFORE INSERT/UPDATE)
--  - Dodatkowo: walidacja daty (reguła biznesowa)
----------------------------------------------------------------
CREATE OR REPLACE TRIGGER trg_val_transakcja_biu
BEFORE INSERT OR UPDATE ON kartoteka_transakcji
FOR EACH ROW
DECLARE
  v_ready NUMBER(1);
BEGIN
  -- Reguła biznesowa: data transakcji nie może być w przyszłości
  IF :NEW.data_transakcji > SYSDATE THEN
    RAISE_APPLICATION_ERROR(-20031, 'Data transakcji nie może być w przyszłości.');
  END IF;

  -- Sprawdzenie gotowości auta
  SELECT gotowy_do_sprzedazy
  INTO v_ready
  FROM samochod
  WHERE id_samochod = :NEW.id_samochod;

  IF v_ready = 0 THEN
    RAISE_APPLICATION_ERROR(-20001, 'Samochód nie jest gotowy do sprzedaży.');
  END IF;
END;
/

----------------------------------------------------------------
-- 3) TRIGGER: Ustawienie auta jako gotowe po dostawie
-- Mapowanie:
--  - Twój PostgreSQL #3: mark_car_ready_after_delivery
--  - Wymóg zadania #3: spójność pośrednia (licznik aut na placu)
----------------------------------------------------------------
CREATE OR REPLACE TRIGGER trg_after_insert_dostawa
AFTER INSERT ON dostawa
FOR EACH ROW
BEGIN
  -- Auto gotowe po dostawie
  UPDATE samochod SET gotowy_do_sprzedazy = 1 WHERE id_samochod = :NEW.id_samochod;

  -- Spójność pośrednia: zwiększenie licznika na placu
  UPDATE plac SET liczba_aut = liczba_aut + 1 WHERE id_plac = :NEW.id_plac;
END;
/

CREATE OR REPLACE TRIGGER trg_after_delete_dostawa
AFTER DELETE ON dostawa
FOR EACH ROW
BEGIN
  -- Spójność pośrednia: korekta licznika po usunięciu dostawy
  UPDATE plac SET liczba_aut = liczba_aut - 1 WHERE id_plac = :OLD.id_plac;
END;
/

----------------------------------------------------------------
-- 4) TRIGGER BLOKUJĄCY USUNIĘCIE samochodu
-- Mapowanie:
--  - Twój PostgreSQL #4: prevent_delete_car_in_transaction
--  - Wymóg zadania #4: blokada usuwania rekordu powiązanego
----------------------------------------------------------------
CREATE OR REPLACE TRIGGER trg_block_delete_samochod
BEFORE DELETE ON samochod
FOR EACH ROW
DECLARE v_count NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_count FROM kartoteka_transakcji WHERE id_samochod = :OLD.id_samochod;
  IF v_count > 0 THEN
    RAISE_APPLICATION_ERROR(-20002, 'Nie można usunąć samochodu powiązanego z transakcją.');
  END IF;
END;
/

----------------------------------------------------------------
-- 4.1) TRIGGER BLOKUJĄCY USUNIĘCIE klienta
-- Mapowanie:
--  - Dodatkowy, żeby dokładnie spełnić przykład z treści zadania
----------------------------------------------------------------
CREATE OR REPLACE TRIGGER trg_block_delete_klient
BEFORE DELETE ON klient
FOR EACH ROW
DECLARE v_count NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_count FROM kartoteka_transakcji WHERE id_klient = :OLD.id_klient;
  IF v_count > 0 THEN
    RAISE_APPLICATION_ERROR(-20021, 'Nie można usunąć klienta mającego transakcje.');
  END IF;
END;
/

----------------------------------------------------------------
-- 5) TRIGGER AUDYTOWY z kontekstem użytkownika/czasu
-- Mapowanie:
--  - Wymóg zadania #2: trigger audytowy
--  - Wymóg zadania #5: użycie SYS_CONTEXT + SYSTIMESTAMP
----------------------------------------------------------------
CREATE OR REPLACE TRIGGER trg_audit_klient_phone
AFTER UPDATE OF telefon ON klient
FOR EACH ROW
WHEN (OLD.telefon != NEW.telefon)
BEGIN
  INSERT INTO audit_log(
    tabela, operacja, pk_value, kolumna, old_value, new_value,
    who_user, who_osuser, who_host, client_id, change_ts
  )
  VALUES(
    'KLIENT', 'UPDATE', TO_CHAR(:OLD.id_klient), 'TELEFON',
    :OLD.telefon, :NEW.telefon,
    SYS_CONTEXT('USERENV','SESSION_USER'),
    SYS_CONTEXT('USERENV','OS_USER'),
    SYS_CONTEXT('USERENV','HOST'),
    SYS_CONTEXT('USERENV','CLIENT_IDENTIFIER'),
    SYSTIMESTAMP
  );
END;
/

----------------------------------------------------------------
-- 6) TRIGGER: Walidacja dat polisy
-- Mapowanie:
--  - Twój PostgreSQL #5: set_default_end_date
--  - Wymóg zadania #1: dodatkowa walidacja reguły biznesowej
----------------------------------------------------------------
CREATE OR REPLACE TRIGGER trg_val_ubezpieczenie_bi
BEFORE INSERT ON ubezpieczenie
FOR EACH ROW
BEGIN
  IF :NEW.data_konca IS NULL THEN
    :NEW.data_konca := ADD_MONTHS(:NEW.data_poczatku, 12);
  END IF;

  IF :NEW.data_konca <= :NEW.data_poczatku THEN
    RAISE_APPLICATION_ERROR(-20041, 'data_konca musi być późniejsza niż data_poczatku.');
  END IF;
END;
/
